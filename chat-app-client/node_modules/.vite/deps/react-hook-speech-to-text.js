import {
  require_react
} from "./chunk-YN3MIK7E.js";
import {
  __toESM
} from "./chunk-4EOJPDL2.js";

// node_modules/react-hook-speech-to-text/dist/index.js
var import_react = __toESM(require_react());
var o = function() {
  return (o = Object.assign || function(e2) {
    for (var t2, n2 = 1, o2 = arguments.length; n2 < o2; n2++)
      for (var r2 in t2 = arguments[n2])
        Object.prototype.hasOwnProperty.call(t2, r2) && (e2[r2] = t2[r2]);
    return e2;
  }).apply(this, arguments);
};
function r(e2, t2, n2, o2) {
  return new (n2 || (n2 = Promise))(function(r2, i2) {
    function a2(e3) {
      try {
        c2(o2.next(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function s2(e3) {
      try {
        c2(o2.throw(e3));
      } catch (e4) {
        i2(e4);
      }
    }
    function c2(e3) {
      var t3;
      e3.done ? r2(e3.value) : (t3 = e3.value, t3 instanceof n2 ? t3 : new n2(function(e4) {
        e4(t3);
      })).then(a2, s2);
    }
    c2((o2 = o2.apply(e2, t2 || [])).next());
  });
}
function i(e2, t2) {
  var n2, o2, r2, i2, a2 = { label: 0, sent: function() {
    if (1 & r2[0])
      throw r2[1];
    return r2[1];
  }, trys: [], ops: [] };
  return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
    return this;
  }), i2;
  function s2(i3) {
    return function(s3) {
      return function(i4) {
        if (n2)
          throw new TypeError("Generator is already executing.");
        for (; a2; )
          try {
            if (n2 = 1, o2 && (r2 = 2 & i4[0] ? o2.return : i4[0] ? o2.throw || ((r2 = o2.return) && r2.call(o2), 0) : o2.next) && !(r2 = r2.call(o2, i4[1])).done)
              return r2;
            switch (o2 = 0, r2 && (i4 = [2 & i4[0], r2.value]), i4[0]) {
              case 0:
              case 1:
                r2 = i4;
                break;
              case 4:
                return a2.label++, { value: i4[1], done: false };
              case 5:
                a2.label++, o2 = i4[1], i4 = [0];
                continue;
              case 7:
                i4 = a2.ops.pop(), a2.trys.pop();
                continue;
              default:
                if (!(r2 = a2.trys, (r2 = r2.length > 0 && r2[r2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                  a2 = 0;
                  continue;
                }
                if (3 === i4[0] && (!r2 || i4[1] > r2[0] && i4[1] < r2[3])) {
                  a2.label = i4[1];
                  break;
                }
                if (6 === i4[0] && a2.label < r2[1]) {
                  a2.label = r2[1], r2 = i4;
                  break;
                }
                if (r2 && a2.label < r2[2]) {
                  a2.label = r2[2], a2.ops.push(i4);
                  break;
                }
                r2[2] && a2.ops.pop(), a2.trys.pop();
                continue;
            }
            i4 = t2.call(e2, a2);
          } catch (e3) {
            i4 = [6, e3], o2 = 0;
          } finally {
            n2 = r2 = 0;
          }
        if (5 & i4[0])
          throw i4[1];
        return { value: i4[0] ? i4[1] : void 0, done: true };
      }([i3, s3]);
    };
  }
}
function a() {
  for (var e2 = 0, t2 = 0, n2 = arguments.length; t2 < n2; t2++)
    e2 += arguments[t2].length;
  var o2 = Array(e2), r2 = 0;
  for (t2 = 0; t2 < n2; t2++)
    for (var i2 = arguments[t2], a2 = 0, s2 = i2.length; a2 < s2; a2++, r2++)
      o2[r2] = i2[a2];
  return o2;
}
var s;
var c = l;
function l() {
}
l.mixin = function(e2) {
  var t2 = e2.prototype || e2;
  t2.isWildEmitter = true, t2.on = function(e3, t3, n2) {
    this.callbacks = this.callbacks || {};
    var o2 = 3 === arguments.length, r2 = o2 ? arguments[1] : void 0, i2 = o2 ? arguments[2] : arguments[1];
    return i2._groupName = r2, (this.callbacks[e3] = this.callbacks[e3] || []).push(i2), this;
  }, t2.once = function(e3, t3, n2) {
    var o2 = this, r2 = 3 === arguments.length, i2 = r2 ? arguments[1] : void 0, a2 = r2 ? arguments[2] : arguments[1];
    function s2() {
      o2.off(e3, s2), a2.apply(this, arguments);
    }
    return this.on(e3, i2, s2), this;
  }, t2.releaseGroup = function(e3) {
    var t3, n2, o2, r2;
    for (t3 in this.callbacks = this.callbacks || {}, this.callbacks)
      for (n2 = 0, o2 = (r2 = this.callbacks[t3]).length; n2 < o2; n2++)
        r2[n2]._groupName === e3 && (r2.splice(n2, 1), n2--, o2--);
    return this;
  }, t2.off = function(e3, t3) {
    this.callbacks = this.callbacks || {};
    var n2, o2 = this.callbacks[e3];
    return o2 ? 1 === arguments.length ? (delete this.callbacks[e3], this) : (-1 !== (n2 = o2.indexOf(t3)) && (o2.splice(n2, 1), 0 === o2.length && delete this.callbacks[e3]), this) : this;
  }, t2.emit = function(e3) {
    this.callbacks = this.callbacks || {};
    var t3, n2, o2, r2 = [].slice.call(arguments, 1), i2 = this.callbacks[e3], a2 = this.getWildcardCallbacks(e3);
    if (i2)
      for (t3 = 0, n2 = (o2 = i2.slice()).length; t3 < n2 && o2[t3]; ++t3)
        o2[t3].apply(this, r2);
    if (a2)
      for (n2 = a2.length, t3 = 0, n2 = (o2 = a2.slice()).length; t3 < n2 && o2[t3]; ++t3)
        o2[t3].apply(this, [e3].concat(r2));
    return this;
  }, t2.getWildcardCallbacks = function(e3) {
    this.callbacks = this.callbacks || {};
    var t3, n2, o2 = [];
    for (t3 in this.callbacks)
      n2 = t3.split("*"), ("*" === t3 || 2 === n2.length && e3.slice(0, n2[0].length) === n2[0]) && (o2 = o2.concat(this.callbacks[t3]));
    return o2;
  };
}, l.mixin(l), "undefined" != typeof window && (s = window.AudioContext || window.webkitAudioContext);
var u = null;
var f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};
var h = !!(f === f.window && f.URL && f.Blob && f.Worker);
function d(e2, t2) {
  var n2, o2 = this;
  if (t2 = t2 || {}, h)
    return n2 = e2.toString().trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1], new f.Worker(f.URL.createObjectURL(new f.Blob([n2], { type: "text/javascript" })));
  this.self = t2, this.self.postMessage = function(e3) {
    setTimeout(function() {
      o2.onmessage({ data: e3 });
    }, 0);
  }, setTimeout(e2.bind(t2, t2), 0);
}
d.prototype.postMessage = function(e2) {
  var t2 = this;
  setTimeout(function() {
    t2.self.onmessage({ data: e2 });
  }, 0);
};
var p = d;
var g = class {
  constructor(e2, t2) {
    this.config = { bufferLen: 4096, numChannels: 1, mimeType: "audio/wav", ...t2 }, this.recording = false, this.callbacks = { getBuffer: [], exportWAV: [] }, this.context = e2.context, this.node = (this.context.createScriptProcessor || this.context.createJavaScriptNode).call(this.context, this.config.bufferLen, this.config.numChannels, this.config.numChannels), this.node.onaudioprocess = (e3) => {
      if (this.recording) {
        for (var t3 = [], n2 = 0; n2 < this.config.numChannels; n2++)
          t3.push(e3.inputBuffer.getChannelData(n2));
        this.worker.postMessage({ command: "record", buffer: t3 });
      }
    }, e2.connect(this.node), this.node.connect(this.context.destination);
    this.worker = new p(function() {
      let e3, t3, n2, o2 = 0, r2 = [];
      function i2() {
        for (let e4 = 0; e4 < t3; e4++)
          r2[e4] = [];
      }
      function a2(e4, t4) {
        let n3 = new Float32Array(t4), o3 = 0;
        for (let t5 = 0; t5 < e4.length; t5++)
          n3.set(e4[t5], o3), o3 += e4[t5].length;
        return n3;
      }
      function s2(e4, t4, n3) {
        for (let o3 = 0; o3 < n3.length; o3++)
          e4.setUint8(t4 + o3, n3.charCodeAt(o3));
      }
      this.onmessage = function(c2) {
        switch (c2.data.command) {
          case "init":
            l2 = c2.data.config, e3 = l2.sampleRate, t3 = l2.numChannels, i2(), n2 = e3 > 48e3 ? 48e3 : e3;
            break;
          case "record":
            !function(e4) {
              for (var n3 = 0; n3 < t3; n3++)
                r2[n3].push(e4[n3]);
              o2 += e4[0].length;
            }(c2.data.buffer);
            break;
          case "exportWAV":
            !function(i3) {
              let c3, l3 = [];
              for (let e4 = 0; e4 < t3; e4++)
                l3.push(a2(r2[e4], o2));
              c3 = 2 === t3 ? function(e4, t4) {
                let n3 = e4.length + t4.length, o3 = new Float32Array(n3), r3 = 0, i4 = 0;
                for (; r3 < n3; )
                  o3[r3++] = e4[i4], o3[r3++] = t4[i4], i4++;
                return o3;
              }(l3[0], l3[1]) : l3[0];
              let u2 = function(e4) {
                let o3 = new ArrayBuffer(44 + 2 * e4.length), r3 = new DataView(o3);
                return s2(r3, 0, "RIFF"), r3.setUint32(4, 36 + 2 * e4.length, true), s2(r3, 8, "WAVE"), s2(r3, 12, "fmt "), r3.setUint32(16, 16, true), r3.setUint16(20, 1, true), r3.setUint16(22, t3, true), r3.setUint32(24, n2, true), r3.setUint32(28, 4 * n2, true), r3.setUint16(32, 2 * t3, true), r3.setUint16(34, 16, true), s2(r3, 36, "data"), r3.setUint32(40, 2 * e4.length, true), function(e5, t4, n3) {
                  for (let o4 = 0; o4 < n3.length; o4++, t4 += 2) {
                    let r4 = Math.max(-1, Math.min(1, n3[o4]));
                    e5.setInt16(t4, r4 < 0 ? 32768 * r4 : 32767 * r4, true);
                  }
                }(r3, 44, e4), r3;
              }(function(t4, n3) {
                if (n3 == e3)
                  return t4;
                if (n3 > e3)
                  throw "downsampling rate show be smaller than original sample rate";
                var o3 = e3 / n3, r3 = Math.round(t4.length / o3), i4 = new Float32Array(r3), a3 = 0, s3 = 0;
                for (; a3 < i4.length; ) {
                  for (var c4 = Math.round((a3 + 1) * o3), l4 = 0, u3 = 0, f3 = s3; f3 < c4 && f3 < t4.length; f3++)
                    l4 += t4[f3], u3++;
                  i4[a3] = l4 / u3, a3++, s3 = c4;
                }
                return i4;
              }(c3, n2)), f2 = new Blob([u2], { type: i3 });
              this.postMessage({ command: "exportWAV", data: f2 });
            }(c2.data.type);
            break;
          case "getBuffer":
            !function() {
              let e4 = [];
              for (let n3 = 0; n3 < t3; n3++)
                e4.push(a2(r2[n3], o2));
              this.postMessage({ command: "getBuffer", data: e4 });
            }();
            break;
          case "clear":
            o2 = 0, r2 = [], i2();
        }
        var l2;
      };
    }, {}), this.worker.postMessage({ command: "init", config: { sampleRate: this.context.sampleRate, numChannels: this.config.numChannels } }), this.worker.onmessage = (e3) => {
      let t3 = this.callbacks[e3.data.command].pop();
      "function" == typeof t3 && t3(e3.data.data);
    };
  }
  record() {
    this.recording = true;
  }
  stop() {
    this.recording = false;
  }
  clear() {
    this.worker.postMessage({ command: "clear" });
  }
  getBuffer(e2) {
    if (!(e2 = e2 || this.config.callback))
      throw new Error("Callback not set");
    this.callbacks.getBuffer.push(e2), this.worker.postMessage({ command: "getBuffer" });
  }
  exportWAV(e2, t2) {
    if (t2 = t2 || this.config.mimeType, !(e2 = e2 || this.config.callback))
      throw new Error("Callback not set");
    this.callbacks.exportWAV.push(e2), this.worker.postMessage({ command: "exportWAV", type: t2 });
  }
  static forceDownload(e2, t2) {
    let n2 = (window.URL || window.webkitURL).createObjectURL(e2), o2 = window.document.createElement("a");
    o2.href = n2, o2.download = t2 || "output.wav";
    let r2 = document.createEvent("Event");
    r2.initEvent("click", true, true), o2.dispatchEvent(r2);
  }
};
var m;
var v;
var w = g;
async function b({ audioContext: e2, errHandler: t2, onStreamLoad: n2 }) {
  try {
    const t3 = await navigator.mediaDevices.getUserMedia({ audio: true });
    return n2 && n2(), m = t3, v = e2.createMediaStreamSource(t3), w = new g(v), w.record(), t3;
  } catch (e3) {
    console.log(e3), t2 && t2();
  }
}
function k({ exportWAV: e2, wavCallback: t2 }) {
  w.stop(), m.getAudioTracks()[0].stop(), e2 && t2 && w.exportWAV((e3) => t2(e3)), w.clear();
}
var y;
var x = -1 !== navigator.userAgent.indexOf("Edg/");
var A = window.AudioContext || window.webkitAudioContext;
var C = window.SpeechRecognition || window.webkitSpeechRecognition;
function R(l2) {
  var f2 = this, h2 = l2.continuous, d2 = l2.crossBrowser, p2 = l2.googleApiKey, g2 = l2.googleCloudRecognitionConfig, m2 = l2.onStartSpeaking, v2 = l2.onStoppedSpeaking, w2 = l2.speechRecognitionProperties, x2 = void 0 === w2 ? { interimResults: true } : w2, C2 = l2.timeout, R2 = void 0 === C2 ? 1e4 : C2, M = l2.useOnlyGoogleCloud, S = void 0 !== M && M, T = l2.useLegacyResults, U = void 0 === T || T, W = (0, import_react.useState)(false), L = W[0], B = W[1], E = (0, import_react.useRef)(), H = (0, import_react.useState)([]), V = H[0], O = H[1], F = (0, import_react.useState)([]), j = F[0], D = F[1], P = (0, import_react.useState)(), I = P[0], _ = P[1], N = (0, import_react.useState)(""), q = N[0], z = N[1], G = (0, import_react.useRef)(), J = (0, import_react.useRef)();
  (0, import_react.useEffect)(function() {
    var e2;
    d2 || y || z("Speech Recognition API is only available on Chrome"), (null === (e2 = null === navigator || void 0 === navigator ? void 0 : navigator.mediaDevices) || void 0 === e2 ? void 0 : e2.getUserMedia) || z("getUserMedia is not supported on this device/browser :("), !d2 && !S || p2 || console.error("No google cloud API key was passed, google API will not be able to process speech"), E.current || (E.current = new A()), U && console.warn("react-hook-speech-to-text is using legacy results, pass useLegacyResults: false to the hook to use the new array of objects results. Legacy array of strings results will be removed in a future version.");
  }, []);
  var K = function() {
    return r(f2, void 0, void 0, function() {
      var e2, t2, n2, o2;
      return i(this, function(r2) {
        switch (r2.label) {
          case 0:
            return !S && y ? (function() {
              if (y) {
                h2 && (y.continuous = true);
                var e3 = x2 || {}, t3 = e3.grammars, n3 = e3.interimResults, o3 = e3.lang, r3 = e3.maxAlternatives;
                t3 && (y.grammars = t3), o3 && (y.lang = o3), y.interimResults = n3 || false, y.maxAlternatives = r3 || 1, y.start(), y.onresult = function(e4) {
                  var t4 = e4.results[e4.results.length - 1], o4 = t4[0].transcript, r4 = Math.floor(Date.now() / 1e3);
                  if (n3)
                    if (t4.isFinal)
                      _(void 0), D(function(e5) {
                        return a(e5, [{ transcript: o4, timestamp: r4 }]);
                      }), O(function(e5) {
                        return a(e5, [o4]);
                      });
                    else {
                      for (var i2 = "", s2 = e4.resultIndex; s2 < e4.results.length; s2++)
                        i2 += e4.results[s2][0].transcript;
                      _(i2);
                    }
                  else
                    D(function(e5) {
                      return a(e5, [{ transcript: o4, timestamp: r4 }]);
                    }), O(function(e5) {
                      return a(e5, [o4]);
                    });
                }, y.onaudiostart = function() {
                  return B(true);
                }, y.onend = function() {
                  B(false);
                };
              }
            }(), [2]) : d2 || S ? ("suspended" === (null === (n2 = E.current) || void 0 === n2 ? void 0 : n2.state) && (null === (o2 = E.current) || void 0 === o2 || o2.resume()), [4, b({ errHandler: function() {
              return z("Microphone permission was denied");
            }, audioContext: E.current })]) : [2];
          case 1:
            return e2 = r2.sent(), B(true), R2 && (clearTimeout(G.current), $()), J.current && X(), J.current = e2.clone(), (t2 = function(e3, t3) {
              var n3 = new c();
              if (!s)
                return n3;
              var o3, r3, i2, a2 = (t3 = t3 || {}).smoothing || 0.1, l3 = t3.interval || 50, f3 = t3.threshold, h3 = t3.play, d3 = t3.history || 10, p3 = true;
              u = t3.audioContext || u || new s(), (i2 = u.createAnalyser()).fftSize = 512, i2.smoothingTimeConstant = a2, r3 = new Float32Array(i2.frequencyBinCount), e3.jquery && (e3 = e3[0]), e3 instanceof HTMLAudioElement || e3 instanceof HTMLVideoElement ? (o3 = u.createMediaElementSource(e3), void 0 === h3 && (h3 = true), f3 = f3 || -50) : (o3 = u.createMediaStreamSource(e3), f3 = f3 || -50), o3.connect(i2), h3 && i2.connect(u.destination), n3.speaking = false, n3.suspend = function() {
                return u.suspend();
              }, n3.resume = function() {
                return u.resume();
              }, Object.defineProperty(n3, "state", { get: function() {
                return u.state;
              } }), u.onstatechange = function() {
                n3.emit("state_change", u.state);
              }, n3.setThreshold = function(e4) {
                f3 = e4;
              }, n3.setInterval = function(e4) {
                l3 = e4;
              }, n3.stop = function() {
                p3 = false, n3.emit("volume_change", -100, f3), n3.speaking && (n3.speaking = false, n3.emit("stopped_speaking")), i2.disconnect(), o3.disconnect();
              }, n3.speakingHistory = [];
              for (var g3 = 0; g3 < d3; g3++)
                n3.speakingHistory.push(0);
              var m3 = function() {
                setTimeout(function() {
                  if (p3) {
                    var e4 = function(e5, t5) {
                      var n4 = -1 / 0;
                      e5.getFloatFrequencyData(t5);
                      for (var o5 = 4, r4 = t5.length; o5 < r4; o5++)
                        t5[o5] > n4 && t5[o5] < 0 && (n4 = t5[o5]);
                      return n4;
                    }(i2, r3);
                    n3.emit("volume_change", e4, f3);
                    var t4 = 0;
                    if (e4 > f3 && !n3.speaking) {
                      for (var o4 = n3.speakingHistory.length - 3; o4 < n3.speakingHistory.length; o4++)
                        t4 += n3.speakingHistory[o4];
                      t4 >= 2 && (n3.speaking = true, n3.emit("speaking"));
                    } else if (e4 < f3 && n3.speaking) {
                      for (o4 = 0; o4 < n3.speakingHistory.length; o4++)
                        t4 += n3.speakingHistory[o4];
                      0 == t4 && (n3.speaking = false, n3.emit("stopped_speaking"));
                    }
                    n3.speakingHistory.shift(), n3.speakingHistory.push(0 + (e4 > f3)), m3();
                  }
                }, l3);
              };
              return m3(), n3;
            }(J.current, { audioContext: E.current })).on("speaking", function() {
              m2 && m2(), clearTimeout(G.current);
            }), t2.on("stopped_speaking", function() {
              v2 && v2(), k({ exportWAV: true, wavCallback: function(e3) {
                return Q({ blob: e3, continuous: h2 || false });
              } });
            }), [2];
        }
      });
    });
  }, $ = function() {
    G.current = window.setTimeout(function() {
      B(false), X(), k({ exportWAV: false });
    }, R2);
  }, Q = function(e2) {
    var t2 = e2.blob, n2 = e2.continuous, s2 = new FileReader();
    s2.readAsDataURL(t2), s2.onloadend = function() {
      return r(f2, void 0, void 0, function() {
        var e3, r2, c2, l3, u2, f3, h3, d3, m3;
        return i(this, function(i2) {
          switch (i2.label) {
            case 0:
              return e3 = s2.result, (r2 = null === (d3 = E.current) || void 0 === d3 ? void 0 : d3.sampleRate) && r2 > 48e3 && (r2 = 48e3), c2 = { content: "" }, l3 = o({ encoding: "LINEAR16", languageCode: "en-US", sampleRateHertz: r2 }, g2), u2 = { config: l3, audio: c2 }, c2.content = e3.substr(e3.indexOf(",") + 1), [4, fetch("https://speech.googleapis.com/v1/speech:recognize?key=" + p2, { method: "POST", body: JSON.stringify(u2) })];
            case 1:
              return [4, i2.sent().json()];
            case 2:
              return f3 = i2.sent(), (null === (m3 = f3.results) || void 0 === m3 ? void 0 : m3.length) > 0 && (h3 = f3.results[0].alternatives[0].transcript, O(function(e4) {
                return a(e4, [h3]);
              }), D(function(e4) {
                return a(e4, [{ speechBlob: t2, transcript: h3, timestamp: Math.floor(Date.now() / 1e3) }]);
              })), n2 ? K() : (X(), B(false)), [2];
          }
        });
      });
    };
  }, X = function() {
    var e2;
    null === (e2 = J.current) || void 0 === e2 || e2.getAudioTracks()[0].stop();
  };
  return { error: q, interimResult: I, isRecording: L, results: U ? V : j, setResults: D, startSpeechToText: K, stopSpeechToText: function() {
    y && !S ? y.stop() : (B(false), X(), k({ exportWAV: true, wavCallback: function(e2) {
      return Q({ blob: e2, continuous: false });
    } }));
  } };
}
navigator.brave && navigator.brave.isBrave().then(function(e2) {
  e2 && (y = null);
}), !x && C && (y = new C());
var dist_default = R;
export {
  dist_default as default
};
//# sourceMappingURL=react-hook-speech-to-text.js.map
